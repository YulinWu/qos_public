# This file is generated by converter.py, don't change, change the source code instead

import jpype
import jpype.imports
from jpype.types import *
import os

def matchArgument(patterns, args):
    if len(patterns) != len(args):
        return False
    for p, v in zip(patterns, args):
        if p.startswith('@NonNull ') and v == None:
            return False
        if p.startswith('@NonNull '):
            p = p[9:]
        vtype = p.split(' ')[-2]
        if vtype[-2:] == '[]' and not isinstance(v, list):
            return False
        if vtype[-4:] == '[][]' and not isinstance(v[0], list):
            return False
    return True

def convertArgument(patterns, args):
    typemap = {
        'boolean': JBoolean,
        'byte': JByte,
        'char': JChar,
        'short': JShort,
        'int': JInt,
        'long': JLong,
        'float': JFloat,
        'double': JDouble,
        'String': JString,

        'boolean[]': JArray(JBoolean),
        'byte[]': JArray(JByte),
        'char[]': JArray(JChar),
        'short[]': JArray(JShort),
        'int[]': JArray(JInt),
        'long[]': JArray(JLong),
        'float[]': JArray(JFloat),
        'double[]': JArray(JDouble),
        'String[]': JArray(JString),

        'boolean[][]': JArray(JArray(JBoolean)),
        'byte[][]': JArray(JArray(JByte)),
        'char[][]': JArray(JArray(JChar)),
        'short[][]': JArray(JArray(JShort)),
        'int[][]': JArray(JArray(JInt)),
        'long[][]': JArray(JArray(JLong)),
        'float[][]': JArray(JArray(JFloat)),
        'double[][]': JArray(JArray(JDouble)),
        'String[][]': JArray(JArray(JString)),

        'boolean[][][]': JArray(JArray(JArray(JBoolean))),
        'byte[][][]': JArray(JArray(JArray(JByte))),
        'char[][][]': JArray(JArray(JArray(JChar))),
        'short[][][]': JArray(JArray(JArray(JShort))),
        'int[][][]': JArray(JArray(JArray(JInt))),
        'long[][][]': JArray(JArray(JArray(JLong))),
        'float[][][]': JArray(JArray(JArray(JFloat))),
        'double[][][]': JArray(JArray(JArray(JDouble))),
        'String[][][]': JArray(JArray(JArray(JString))),
    }
    args2 = []
    for p, v in zip(patterns, args):
        vtype = p.split(' ')[-2]
        args2.append(typemap[vtype](v))
    return args2


jpype.startJVM(classpath=[os.path.abspath(os.path.dirname(
    __file__))+'/../../rpcapi/target/qos-rpcapi-1.0.jar'])
# jpype.startJVM(classpath=[os.path.abspath(
#     os.path.dirname(__file__))+'/../../rpcapi/target/classes'])

QOSServerApi = jpype.JClass('qc.qos.rpcapi.qpx1701.QOSServerApi')


class g:
    Instance = None


def getInstance(*args):
    patterns = ['@NonNull String userName',
                'String password',
                '@NonNull String host',
                'int port']
    if matchArgument(patterns, args):
        args = convertArgument(patterns, args)
        g.Instance = QOSServerApi(*args)
        return
    patterns = ['@NonNull String userName',
                'String password',
                '@NonNull String host',
                'int port',
                'boolean useSSL',
                'String keyFile',
                'char[] keyStorePassword']
    if matchArgument(patterns, args):
        args = convertArgument(patterns, args)
        g.Instance = QOSServerApi(*args)
        return
    raise TypeError('no input pattern match')


def bootup(*args):
    patternsList = [
        ["@NonNull String processorConfFile", "@NonNull String shiroIniFile", "@NonNull String systemId", "@NonNull String sampleId"],

        ["@NonNull String settingsStoreUserName", "@NonNull String settingsStorePassword", "@NonNull String configServerName", "@NonNull String labradManagerHost", "@NonNull int labradManagerPort", "@NonNull String labradPassword", "@NonNull String qHWSession", "@NonNull String shiroIniFile", "@NonNull String systemId", "@NonNull String sampleId"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.bootup(*args)
            return
    raise TypeError('no input pattern match in bootup')
    
def shutdown(*args):
    patternsList = [
        ["@NonNull String shutdownAuthorizationCode"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.shutdown(*args)
            return
    raise TypeError('no input pattern match in shutdown')
    
def login(*args):
    patternsList = [
        ["@NonNull String password", "@NonNull String[] userAgents", "@NonNull String user1AgentSoftPropsFolder", "@NonNull String dataPath", "String controlGraphName"],

        ["@NonNull String password", "@NonNull String[] userAgents", "@NonNull String settingsStoreUserName", "@NonNull String settingsStorePassword", "@NonNull String userSession", "@NonNull String dataPath", "String controlGraphName"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.login(*args)
            return
    raise TypeError('no input pattern match in login')
    
def logout(*args):
    patternsList = [
        ["@NonNull String password"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.logout(*args)
            return
    raise TypeError('no input pattern match in logout')
    
def reloadSettings(*args):
    patternsList = [
        ["@NonNull String password"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.reloadSettings(*args)
            return
    raise TypeError('no input pattern match in reloadSettings')
    
def getQPUInfo(*args):
    patternsList = [
        []]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.getQPUInfo(*args)
            return
    raise TypeError('no input pattern match in getQPUInfo')
    
def restartHardware(*args):
    patternsList = [
        ["@NonNull String[] hardwareSetsToBeRestarted"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.restartHardware(*args)
            return
    raise TypeError('no input pattern match in restartHardware')
    
def runReadoutIQ(*args):
    patternsList = [
        ["@NonNull String[] readoutAgents", "@NonNull float[] readoutAmplitudes", "@NonNull float[] sidebandFrequencies", "boolean amplifierOff", "float amplifierOffLoPower", "@NonNull float[][] frequencies", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"],

        ["@NonNull String[] readoutQubits", "@NonNull String[] driveQubits", "@NonNull String[] driveGates", "@NonNull String[] biasQubits", "boolean isDCBias", "boolean biasDriveGateOnly", "boolean saveIQRaw", "boolean doFit", "@NonNull float[][] frequencies", "@NonNull float[][] amplitudes", "@NonNull float[][] biasAmplitudes", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runReadoutIQ(*args)
            return
    raise TypeError('no input pattern match in runReadoutIQ')
    
def runIMPABringup0(*args):
    patternsList = [
        ["@NonNull String jpaAgent", "@NonNull String readoutAgent", "@NonNull float[] signalAmplitude", "@NonNull float[] signalFrequency", "@NonNull float signalSidebandFrequency", "@NonNull float[] biasAmplitude", "@NonNull float[] pumpAmplitude", "@NonNull float[] pumpLoFrequency", "@NonNull float[] pumpSidebandFrequencies", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runIMPABringup0(*args)
            return
    raise TypeError('no input pattern match in runIMPABringup0')
    
def runIMPABringup1(*args):
    patternsList = [
        ["@NonNull String[] jpaAgents", "@NonNull String[] readoutAgents", "boolean pumpWithMixer", "@NonNull float[][] biasAmplitudes", "@NonNull float[][] pumpAmplitudes", "@NonNull float[][] pumpLoFrequencies", "@NonNull float[][] pumpSidebandFrequencies", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runIMPABringup1(*args)
            return
    raise TypeError('no input pattern match in runIMPABringup1')
    
def runIMPAGainBaseOptimizerSimplexTriImpl0(*args):
    patternsList = [
        ["@NonNull String[] jpaAgents", "@NonNull String[] readoutAgents", "boolean pumpWithMixer", "float jpaOffLoPower", "int maxEval", "@NonNull float[] biasAmplitudeLBs", "@NonNull float[] biasAmplitudeUBs", "@NonNull float[] pumpAmplitudeLBs", "@NonNull float[] pumpAmplitudeUBs", "@NonNull float[] pumpLoFrequencyLBs", "@NonNull float[] pumpLoFrequencyUBs", "@NonNull float[] biasAmplitudeDeltas", "@NonNull float[] pumpAmplitudeDeltas", "@NonNull float[] pumpLoFrequenciesDeltas", "float g0", "float g1", "float g2", "float loMinFrequency", "boolean continuousExecution", "boolean enableParallelMode", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runIMPAGainBaseOptimizerSimplexTriImpl0(*args)
            return
    raise TypeError('no input pattern match in runIMPAGainBaseOptimizerSimplexTriImpl0')
    
def runSpectroscopyZDCLo(*args):
    patternsList = [
        ["@NonNull String driveQubit", "int driveLength", "float driveAmplitude", "float driveSBFrequency", "@NonNull String biasQubit", "@NonNull String readoutQubit", "@NonNull String dataType", "@NonNull float[] biasDCLevel", "@NonNull float[] driveFrequency", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runSpectroscopyZDCLo(*args)
            return
    raise TypeError('no input pattern match in runSpectroscopyZDCLo')
    
def runSpectroscopyZPALo(*args):
    patternsList = [
        ["@NonNull String driveQubit", "int driveLength", "float driveAmplitude", "float driveSBFrequency", "@NonNull String biasQubit", "@NonNull String readoutQubit", "@NonNull String[] detuneAgents", "@NonNull float[] detuneAmplitudes", "@NonNull String dataType", "@NonNull float[] biasAmplitudes", "@NonNull float[] driveFrequencies", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runSpectroscopyZPALo(*args)
            return
    raise TypeError('no input pattern match in runSpectroscopyZPALo')
    
def runSpectroscopyZPALoAFR(*args):
    patternsList = [
        ["@NonNull String qubit", "int driveLength", "float driveAmplitude", "float peakAmplitudeLB", "float driveSBFrequency", "float frequencyRange", "float frequencyStep", "@NonNull String[] detuneAgents", "@NonNull float[] detuneAmplitudes", "@NonNull float[] biasAmplitudes", "@NonNull String fitterType", "float fah", "float fitErrorUB", "float kfEstimation", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runSpectroscopyZPALoAFR(*args)
            return
    raise TypeError('no input pattern match in runSpectroscopyZPALoAFR')
    
def runAnharmonicity(*args):
    patternsList = [
        ["@NonNull String[] qubits", "int driveLength", "@NonNull float[] driveAmplitudes", "@NonNull float[][] frequencies", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runAnharmonicity(*args)
            return
    raise TypeError('no input pattern match in runAnharmonicity')
    
def runSpectroscopyZPASB(*args):
    patternsList = [
        ["@NonNull String[] driveNReadoutQubits", "int driveLength", "@NonNull float[] driveAmplitudes", "float loFrequency", "@NonNull String[] biasAgents", "boolean biasAgentsAreXTGsNTurnOffXtalkCompensation", "@NonNull String[] detuneAgents", "@NonNull float[] detuneAmplitudes", "@NonNull String dataType", "@NonNull float[][] biasAmplitudes", "@NonNull float[][] driveFrequencies", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runSpectroscopyZPASB(*args)
            return
    raise TypeError('no input pattern match in runSpectroscopyZPASB')
    
def runFixedFrequencySpectroscopy(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull int[] driveLengths", "int biasLength", "float loFrequency", "@NonNull float[] driveFrequencies", "@NonNull String dataType", "@NonNull float[][] biasAmplitudes", "@NonNull float[][] driveAmplitudes", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runFixedFrequencySpectroscopy(*args)
            return
    raise TypeError('no input pattern match in runFixedFrequencySpectroscopy')
    
def runRabiAmpDetune(*args):
    patternsList = [
        ["@NonNull String[] driveQubits", "@NonNull String[] readoutQubits", "@NonNull String driveGate", "int numDriveGates", "@NonNull String dataType", "@NonNull float[] xyAmplitude", "@NonNull float[] f01s", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"],

        ["@NonNull String[] qubits", "@NonNull String[] workBiasQubits", "@NonNull float[] workBiasAmplitudes", "@NonNull String[] driveGates", "@NonNull int[] numDriveGates", "@NonNull String dataType", "@NonNull float[][] xyAmplitudes", "@NonNull float[][] detunings", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runRabiAmpDetune(*args)
            return
    raise TypeError('no input pattern match in runRabiAmpDetune')
    
def runT1(*args):
    patternsList = [
        ["@NonNull String qubit", "@NonNull String dataType", "boolean measureReference", "@NonNull float[] detuneAmplitude", "@NonNull int[] delay", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"],

        ["@NonNull String[] qubits", "@NonNull String dataType", "boolean measureReference", "boolean detuneInFrequency", "@NonNull float[][] detuneAmplitudes", "@NonNull int[][] delays", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runT1(*args)
            return
    raise TypeError('no input pattern match in runT1')
    
def runRamsey(*args):
    patternsList = [
        ["@NonNull String qubit", "int numDDs", "@NonNull String dataType", "boolean detuneMode", "@NonNull int[] delays", "@NonNull float[] detunings", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"],

        ["@NonNull String[] qubits", "@NonNull String[] workBiasQubits", "@NonNull float[] workBiasAmplitudes", "@NonNull int[] numDDs", "@NonNull String dataType", "boolean detuneMode", "@NonNull int[][] delays", "@NonNull float[][] detunings", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runRamsey(*args)
            return
    raise TypeError('no input pattern match in runRamsey')
    
def runRamseyEnvelop(*args):
    patternsList = [
        ["@NonNull String qubit", "int numDDs", "@NonNull float[] detunings", "@NonNull int[] delays", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"],

        ["@NonNull String[] qubits", "int numDDs", "@NonNull float[][] detunings", "@NonNull int[][] delays", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runRamseyEnvelop(*args)
            return
    raise TypeError('no input pattern match in runRamseyEnvelop')
    
def runDRAGAlphaAPE(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull float[][] dragAlphas", "@NonNull int[] numIs", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runDRAGAlphaAPE(*args)
            return
    raise TypeError('no input pattern match in runDRAGAlphaAPE')
    
def runXYGateDetuning(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull int[] numIs", "@NonNull float[] dragAlphas", "@NonNull float[][] detunings", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runXYGateDetuning(*args)
            return
    raise TypeError('no input pattern match in runXYGateDetuning')
    
def runZDistortion(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull float[] zBiasAmplitudes", "@NonNull int zBiasLength", "@NonNull int[] delays", "@NonNull String phaseMode", "int slidingWindowWidth", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runZDistortion(*args)
            return
    raise TypeError('no input pattern match in runZDistortion')
    
def runReadoutPhotonNumber(*args):
    patternsList = [
        ["@NonNull String[] readoutAgents", "@NonNull String[] qubits", "@NonNull int[] readoutDriveLengths", "@NonNull int[] qubitDriveLengths", "@NonNull float[] qubitDriveAmplitudes", "@NonNull String dataType", "@NonNull float[][] qubitDriveFrequencies", "@NonNull int[][] qubitDriveDelays", "@NonNull float[][] readoutDriveAmplitudes", "@NonNull float[][] readoutDriveFrequencies", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runReadoutPhotonNumber(*args)
            return
    raise TypeError('no input pattern match in runReadoutPhotonNumber')
    
def runQQSwap(*args):
    patternsList = [
        ["@NonNull String sweepDetuneQubit", "@NonNull String fixedDetuneQubit", "@NonNull String[] otherDetuneQubits", "float fixedDetuneAmplitude", "@NonNull float[] otherDetuneAmplitudes", "@NonNull String driveGate1", "@NonNull String driveGate2", "@NonNull String dataType", "@NonNull float[] amplitudes", "@NonNull int[] swapTimes", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runQQSwap(*args)
            return
    raise TypeError('no input pattern match in runQQSwap')
    
def runDriveBiasTiming(*args):
    patternsList = [
        ["@NonNull String[] xyDriveQubits", "@NonNull String[] zBiasAgents", "@NonNull int[] zBiasLengths", "@NonNull float[] zBiasAmplitudes", "boolean netZeroZBias", "@NonNull int[][] delays", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runDriveBiasTiming(*args)
            return
    raise TypeError('no input pattern match in runDriveBiasTiming')
    
def runQGTimingBiasXTalkImpl(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] couplers", "@NonNull int[] zBiasLengths", "@NonNull float[] zBiasAmplitudes", "@NonNull int[][] delays", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runQGTimingBiasXTalkImpl(*args)
            return
    raise TypeError('no input pattern match in runQGTimingBiasXTalkImpl')
    
def runZXTalk(*args):
    patternsList = [
        ["@NonNull String sourceAgent", "@NonNull String targetQubit", "int pulseLength", "int numPulses", "float[] pulseAmplitudes", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runZXTalk(*args)
            return
    raise TypeError('no input pattern match in runZXTalk')
    
def runACZLengthAmplitude(*args):
    patternsList = [
        ["@NonNull String aczAgent", "@NonNull String qubit1DriveGate", "@NonNull String qubit2DriveGate", "@NonNull String dataType", "@NonNull int[] aczLength", "@NonNull float[] aczAmplitude", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runACZLengthAmplitude(*args)
            return
    raise TypeError('no input pattern match in runACZLengthAmplitude')
    
def runRamseyErrorFilter(*args):
    patternsList = [
        ["@NonNull String aczAgent", "@NonNull int[] delays", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runRamseyErrorFilter(*args)
            return
    raise TypeError('no input pattern match in runRamseyErrorFilter')
    
def runSimpleStateTomography(*args):
    patternsList = [
        ["@NonNull String[] qubits", "boolean jointMode", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runSimpleStateTomography(*args)
            return
    raise TypeError('no input pattern match in runSimpleStateTomography')
    
def runSingleQStateTomography(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] initializationGates", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runSingleQStateTomography(*args)
            return
    raise TypeError('no input pattern match in runSingleQStateTomography')
    
def runSimpleProcessTomography1Q(*args):
    patternsList = [
        ["@NonNull String qubit", "@NonNull String[] process", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runSimpleProcessTomography1Q(*args)
            return
    raise TypeError('no input pattern match in runSimpleProcessTomography1Q')
    
def runSimpleProcessTomography2Q(*args):
    patternsList = [
        ["@NonNull String coupler", "@NonNull String[] process", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runSimpleProcessTomography2Q(*args)
            return
    raise TypeError('no input pattern match in runSimpleProcessTomography2Q')
    
def runSingleQAXYStateTomography(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull float[][] gateAmplitudes", "@NonNull float[][] detunings", "@NonNull float[][] alphas", "@NonNull int[][] lengths", "@NonNull float[][] azimuths", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runSingleQAXYStateTomography(*args)
            return
    raise TypeError('no input pattern match in runSingleQAXYStateTomography')
    
def runRandomizedBenchmarking1Q(*args):
    patternsList = [
        ["@NonNull String qubit", "String benchMarkGate", "int ILength", "boolean measureReference", "boolean measureInterleaved", "boolean measureState2", "@NonNull int[] numClifords", "@NonNull int[] numRandomSequences", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"],

        ["@NonNull String[] qubits", "String benchMarkGate", "int ILength", "boolean measureReference", "boolean measureInterleaved", "@NonNull int[] numClifords", "@NonNull int[] numRandomSequences", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runRandomizedBenchmarking1Q(*args)
            return
    raise TypeError('no input pattern match in runRandomizedBenchmarking1Q')
    
def runRandomizedBenchmarking2Q(*args):
    patternsList = [
        ["@NonNull String aczAgent", "String benchMarkGate", "int ILength", "boolean measureReference", "boolean measureInterleaved", "@NonNull int[] numClifords", "@NonNull int[] numRandomSequences", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runRandomizedBenchmarking2Q(*args)
            return
    raise TypeError('no input pattern match in runRandomizedBenchmarking2Q')
    
def runRBXEBImpl1Q(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] interleavingQCircuit", "@NonNull double[][] interleavingCircuitMatrix", "boolean measureState2", "@NonNull int[] numCycles", "@NonNull int[] numRandomSequences", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runRBXEBImpl1Q(*args)
            return
    raise TypeError('no input pattern match in runRBXEBImpl1Q')
    
def runRBXTGFSimXEBImpl(*args):
    patternsList = [
        ["@NonNull String[] couplers", "@NonNull int[] fSimIndexes", "boolean measureState2", "@NonNull int[] numCycles", "@NonNull int[] numRandomSequences", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runRBXTGFSimXEBImpl(*args)
            return
    raise TypeError('no input pattern match in runRBXTGFSimXEBImpl')
    
def runOptimalReadoutFrequencyCal(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] biasAwayQubits", "@NonNull float[] biasAmplitudes", "@NonNull double[] frequencyRanges", "int numSamples", "float minSNR", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"],

        ["@NonNull String[] qubits", "@NonNull String[] biasAwayQubits", "@NonNull float[] biasAmplitudes", "boolean measureState2", "boolean forParamSet012", "@NonNull double[] frequencyRanges", "int numSamples", "float minSNR", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runOptimalReadoutFrequencyCal(*args)
            return
    raise TypeError('no input pattern match in runOptimalReadoutFrequencyCal')
    
def runIQ2Probability(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] biasAwayQubits", "@NonNull float[] biasAmplitudes", "boolean measureState2", "boolean forParamSet012", "double maxDrift", "double minSNR", "double maxSNRDrop", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runIQ2Probability(*args)
            return
    raise TypeError('no input pattern match in runIQ2Probability')
    
def runErrorVsReadoutAmplitude(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull float[][] amplitudes", "boolean measureState2", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runErrorVsReadoutAmplitude(*args)
            return
    raise TypeError('no input pattern match in runErrorVsReadoutAmplitude')
    
def runReadoutFrequencyFinder(*args):
    patternsList = [
        ["@NonNull String[] readoutAgents", "@NonNull float[] readoutAmplitudesH", "@NonNull float[] readoutAmplitudesL", "@NonNull float[] sidebandFrequencies", "float dipWidthEstimation", "float dispersiveShiftEstimation", "float frequencyStep", "float minDipAmplitude", "float maxOverallFrequencyShift", "float maxIndividualFrequencyShift", "float minSeparation", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runReadoutFrequencyFinder(*args)
            return
    raise TypeError('no input pattern match in runReadoutFrequencyFinder')
    
def runReadoutFrequencyPowerDependency(*args):
    patternsList = [
        ["@NonNull String[] qubits", "float readoutAmplitude0", "float readoutAmplitude1", "int numReadoutAmplitudes", "float dipWidthEstimation", "float chiEstimation", "float frequencyStep", "float minDipAmplitude", "boolean alwaysUpdate", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runReadoutFrequencyPowerDependency(*args)
            return
    raise TypeError('no input pattern match in runReadoutFrequencyPowerDependency')
    
def runReadoutFrequencyNAmplitudeOptimizer(*args):
    patternsList = [
        ["@NonNull String[] qubits", "String[] biasAwayQubits", "float[] biasAmplitudes", "@NonNull float[] dipWidths", "boolean measureState2", "int maxIteration", "float minSNR", "float maxOutlierRatio", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runReadoutFrequencyNAmplitudeOptimizer(*args)
            return
    raise TypeError('no input pattern match in runReadoutFrequencyNAmplitudeOptimizer')
    
def runCorrectF01ByPhaseTomo(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] workBiasQubits", "@NonNull float[] workBiasAmplitudes", "@NonNull int[] numDDs", "@NonNull int[][] delays", "float f01DriftLimit", "float fitErrorUB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runCorrectF01ByPhaseTomo(*args)
            return
    raise TypeError('no input pattern match in runCorrectF01ByPhaseTomo')
    
def runF01DriftVsTime(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] workBiasQubits", "@NonNull float[] workBiasAmplitudes", "@NonNull int[] numDDs", "@NonNull int[][] delays", "int takeDelayInSeconds", "int totalTimeDurationInSeconds", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runF01DriftVsTime(*args)
            return
    raise TypeError('no input pattern match in runF01DriftVsTime')
    
def runXYGateAmplitudeRabiCal(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] workBiasQubits", "@NonNull float[] workBiasAmplitudes", "int numDataPoints", "@NonNull int[] numPis", "@NonNull String gate", "float fitErrorUB", "float minVisibility", "float maxDrift", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runXYGateAmplitudeRabiCal(*args)
            return
    raise TypeError('no input pattern match in runXYGateAmplitudeRabiCal')
    
def runXYGateHPiRBClifordOptimizer0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "int maxEval", "int numClifords", "int numRandomSequences", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runXYGateHPiRBClifordOptimizer0(*args)
            return
    raise TypeError('no input pattern match in runXYGateHPiRBClifordOptimizer0')
    
def runXYGateRBClifordOptimizer0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "int maxEval", "int numClifords", "int numRandomSequences", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runXYGateRBClifordOptimizer0(*args)
            return
    raise TypeError('no input pattern match in runXYGateRBClifordOptimizer0')
    
def runXYGateRBIQSBOptimizer(*args):
    patternsList = [
        ["@NonNull String[] qubits", "int maxEval", "int numClifords", "int numRandomSequences", "float epsilonLB", "float epsilonUB", "float deltaLB", "float deltaUB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runXYGateRBIQSBOptimizer(*args)
            return
    raise TypeError('no input pattern match in runXYGateRBIQSBOptimizer')
    
def runXYGateAmplitudeIniCal(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] workBiasQubits", "@NonNull float[] workBiasAmplitudes", "int numDataPoints", "@NonNull String gate", "float minSNR", "boolean adjustGateLengthIfOutOfBounds", "float gateAmplitudeLB", "float gateAmplitudeUB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runXYGateAmplitudeIniCal(*args)
            return
    raise TypeError('no input pattern match in runXYGateAmplitudeIniCal')
    
def runZDistortionCalExpDecay(*args):
    patternsList = [
        ["@NonNull String[] qubits", "int zBiasLength", "@NonNull float[] zBiasAmplitudes", "@NonNull int[] delays", "@NonNull float[] alphaLowerBound", "@NonNull float[] alphaUpperBound", "@NonNull int[] decayTimeUpperBound", "float fitErrorUpperBound", "float lowpassFilterBandWidth", "@NonNull String phaseMode", "int slidingWindowWidth", "float maxResidualRatio", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runZDistortionCalExpDecay(*args)
            return
    raise TypeError('no input pattern match in runZDistortionCalExpDecay')
    
def runDRAGAlphaCal(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull float[] alphaRanges", "@NonNull int[][] numIs", "int numDataPoints", "float visibilityLB", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "float changeBound"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runDRAGAlphaCal(*args)
            return
    raise TypeError('no input pattern match in runDRAGAlphaCal')
    
def runReadoutIQLoCalibrator(*args):
    patternsList = [
        ["@NonNull String[] readoutAgents", "@NonNull float[][] loFrequencies", "float iqZerosLB", "float iqZerosUB", "int maxEval", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "boolean verbose"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runReadoutIQLoCalibrator(*args)
            return
    raise TypeError('no input pattern match in runReadoutIQLoCalibrator')
    
def runReadoutIQSBCalibrator(*args):
    patternsList = [
        ["@NonNull String[] readoutAgents", "@NonNull float[] readoutAmplitudes", "@NonNull float[][] loFrequencies", "@NonNull float[][] sidebandFrequencies", "double epsilonLB", "float epsilonUB", "float deltaLB", "float deltaUB", "int maxEval", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "boolean verbose"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runReadoutIQSBCalibrator(*args)
            return
    raise TypeError('no input pattern match in runReadoutIQSBCalibrator')
    
def runReadoutIQGShift(*args):
    patternsList = [
        ["@NonNull String[] couplers", "@NonNull boolean[] measureQ0s", "@NonNull String[] detuneQubits", "@NonNull float[] detuneAmplitudes", "@NonNull float[][] biasAmplitudes", "boolean isDCBias", "boolean isDCDetune", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runReadoutIQGShift(*args)
            return
    raise TypeError('no input pattern match in runReadoutIQGShift')
    
def runQQSwapG(*args):
    patternsList = [
        ["@NonNull String[] couplers", "@NonNull float[] detuneAmplitude0s", "@NonNull float[] detuneAmplitude1s", "boolean isDCBias", "@NonNull String[] driveGate0s", "@NonNull String[] driveGate1s", "@NonNull String dataType", "@NonNull float[][] couplerBiasAmplitudes", "@NonNull int[][] swapTimes", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runQQSwapG(*args)
            return
    raise TypeError('no input pattern match in runQQSwapG')
    
def runCPhaseG(*args):
    patternsList = [
        ["@NonNull String[] couplers", "@NonNull boolean[] measureQ0s", "@NonNull float[] detuneAmplitude0s", "@NonNull float[] detuneAmplitude1s", "boolean isDCBias", "@NonNull float[][] couplerBiasAmplitudes", "@NonNull int[][] swapTimes", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runCPhaseG(*args)
            return
    raise TypeError('no input pattern match in runCPhaseG')
    
def runFSim(*args):
    patternsList = [
        ["@NonNull String[] couplers", "@NonNull int[] fSimIndexes", "int numGates", "@NonNull String dataType", "@NonNull String[] driveGate0s", "@NonNull String[] driveGate1s", "@NonNull float[][] activeLengths", "@NonNull int[][] fSimDetuneEdgeWidths", "@NonNull int[][] fSimGEdgeWidths", "@NonNull float[][] fSimDetunes", "@NonNull boolean[] isDetune1stQubits", "@NonNull float[][] fSimGs", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runFSim(*args)
            return
    raise TypeError('no input pattern match in runFSim')
    
def runFSimActiveLengthVsLeakage(*args):
    patternsList = [
        ["@NonNull String[] couplers", "@NonNull int[] fSimIndexes", "int numCycles", "int numRandomSequences", "float[][] activeLengths", "boolean continuousExecution", "boolean enableParallelMode", "int numShots", "@NonNull String notes"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runFSimActiveLengthVsLeakage(*args)
            return
    raise TypeError('no input pattern match in runFSimActiveLengthVsLeakage')
    
def runIQ2ProbabilityNodeCompareToHistoryImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] biasAwayQubits", "@NonNull float[] biasAmplitudes", "boolean measureState2", "boolean forParamSet012", "float minSNR", "float maxSNRDrop", "float maxOutlierRatio", "float maxDrift", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runIQ2ProbabilityNodeCompareToHistoryImpl0(*args)
            return
    raise TypeError('no input pattern match in runIQ2ProbabilityNodeCompareToHistoryImpl0')
    
def runIQ2ProbabilityNodeMultiRunImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] biasAwayQubits", "@NonNull float[] biasAmplitudes", "boolean measureState2", "boolean forParamSet012", "int numRuns", "int successThreshold", "float minSNR", "float maxOutlierRatio", "float clusterDistance", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runIQ2ProbabilityNodeMultiRunImpl0(*args)
            return
    raise TypeError('no input pattern match in runIQ2ProbabilityNodeMultiRunImpl0')
    
def runIQ2ProbabilityNodeWithBackupImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] biasAwayQubits", "@NonNull float[] biasAmplitudes", "boolean measureState2", "boolean forParamSet012", "float minSNR", "float maxSNRDrop", "float maxOutlierRatio", "float maxDrift", "int numRepeatOfMainCal", "int numRuns", "int successThreshold", "float clusterDistance", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runIQ2ProbabilityNodeWithBackupImpl0(*args)
            return
    raise TypeError('no input pattern match in runIQ2ProbabilityNodeWithBackupImpl0')
    
def runReadoutFrequencyFinderNodeImpl0(*args):
    patternsList = [
        ["@NonNull String[] readoutAgents", "@NonNull float[] readoutAmplitudesH", "@NonNull float[] readoutAmplitudesL", "@NonNull float[] sidebandFrequencies", "float dipWidthEstimation", "float dispersiveShiftEstimation", "float frequencyStep", "float maxOverallFrequencyShift", "float maxIndividualFrequencyShift", "float minSeparation", "float amplifierOffLoPower", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runReadoutFrequencyFinderNodeImpl0(*args)
            return
    raise TypeError('no input pattern match in runReadoutFrequencyFinderNodeImpl0')
    
def runReadoutFrequencyPowerDependencyNodeImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "float readoutAmplitude0", "float readoutAmplitude1", "@NonNull int numReadoutAmplitudes", "float dipWidthEstimation", "float shiftLB", "float shiftEstimation", "float frequencyStep", "float minDipAmplitude", "float minSNR", "boolean alwaysUpdate", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runReadoutFrequencyPowerDependencyNodeImpl0(*args)
            return
    raise TypeError('no input pattern match in runReadoutFrequencyPowerDependencyNodeImpl0')
    
def runReadoutFrequencyBiasDependencyNodeImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull float[] bias0s", "@NonNull float[] bias1s", "@NonNull int numBiases", "boolean isDCBias", "float dipWidth", "float chiEstimation", "float frequencyStep", "float minDipAmplitude", "float minSNR", "float minTuneRange", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runReadoutFrequencyBiasDependencyNodeImpl0(*args)
            return
    raise TypeError('no input pattern match in runReadoutFrequencyBiasDependencyNodeImpl0')
    
def runXYGateAmplitudeIniCalNodeImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] workBiasQubits", "@NonNull float[] workBiasAmplitudes", "int numDataPoints", "@NonNull String gate", "float minSNR", "boolean adjustGateLengthIfOutOfBounds", "float gateAmplitudeLB", "float gateAmplitudeUB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runXYGateAmplitudeIniCalNodeImpl0(*args)
            return
    raise TypeError('no input pattern match in runXYGateAmplitudeIniCalNodeImpl0')
    
def runXYGateAmplitudeIniCalNodeWithBackupImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] workBiasQubits", "@NonNull float[] workBiasAmplitudes", "int numDataPoints", "@NonNull String gate", "float minSNR", "boolean adjustGateLengthIfOutOfBounds", "float gateAmplitudeLB", "float gateAmplitudeUB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runXYGateAmplitudeIniCalNodeWithBackupImpl0(*args)
            return
    raise TypeError('no input pattern match in runXYGateAmplitudeIniCalNodeWithBackupImpl0')
    
def runCorrectF01NodePhaseTomoImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] workBiasQubits", "@NonNull float[] workBiasAmplitudes", "@Nonnegative int numDDs", "int maxDelay", "int delayStep", "float f01DriftLimit", "float absoluteErrorUB", "float snrLB", "float snrCheckF01DriftLB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runCorrectF01NodePhaseTomoImpl0(*args)
            return
    raise TypeError('no input pattern match in runCorrectF01NodePhaseTomoImpl0')
    
def runCorrectF01NodeWithBackupPhaseTomoImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] workBiasQubits", "@NonNull float[] workBiasAmplitudes", "@Nonnegative int numDDs", "int maxDelay", "int delayStep", "int shrinkFactor", "float f01DriftLimit", "float absoluteErrorUB", "float snrLB", "float snrCheckF01DriftLB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runCorrectF01NodeWithBackupPhaseTomoImpl0(*args)
            return
    raise TypeError('no input pattern match in runCorrectF01NodeWithBackupPhaseTomoImpl0')
    
def runCorrectF01NodeRabiDetuneImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] workBiasQubits", "@NonNull float[] workBiasAmplitudes", "@Nonnegative int numDataPoints", "float f01DriftLimit", "float fitErrorUB", "boolean updateF01", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runCorrectF01NodeRabiDetuneImpl0(*args)
            return
    raise TypeError('no input pattern match in runCorrectF01NodeRabiDetuneImpl0')
    
def runDRAGAlphaCalNodeImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull float[] alphaRanges", "@NonNull int[][] numIs", "int numDataPoints", "float visibilityLB", "float alphaLB", "float alphaUB", "float alphaChangeUB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runDRAGAlphaCalNodeImpl0(*args)
            return
    raise TypeError('no input pattern match in runDRAGAlphaCalNodeImpl0')
    
def runDRAGAlphaCalNodeWithBackupImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull float[] alphaRangesFine", "@NonNull float[] alphaRangesCoarse", "@NonNull int[][] numIsFine", "@NonNull int[][] numIsCoarse", "int numDataPoints", "float visibilityLB", "float alphaLB", "float alphaUB", "float alphaChangeUB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runDRAGAlphaCalNodeWithBackupImpl0(*args)
            return
    raise TypeError('no input pattern match in runDRAGAlphaCalNodeWithBackupImpl0')
    
def runIMPAGainOptimizationNodeSimplexTriImpl0(*args):
    patternsList = [
        ["@NonNull String[] jpaAgents", "@NonNull String[] readoutAgents", "boolean pumpWithMixer", "float jpaOffLoPower", "int maxIteration", "@NonNull float[] biasAmplitudeLBs", "@NonNull float[] biasAmplitudeUBs", "@NonNull float[] pumpAmplitudeLBs", "@NonNull float[] pumpAmplitudeUBs", "@NonNull float[] pumpLoFrequencyLBs", "@NonNull float[] pumpLoFrequencyUBs", "@NonNull float[] biasAmplitudeDeltas", "@NonNull float[] pumpAmplitudeDeltas", "@NonNull float[] pumpLoFrequenciesDeltas", "float g0", "float g1", "float g2", "float loMinFrequency", "@Nonnegative float minGain", "@Nonnegative float maxGain", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runIMPAGainOptimizationNodeSimplexTriImpl0(*args)
            return
    raise TypeError('no input pattern match in runIMPAGainOptimizationNodeSimplexTriImpl0')
    
def runIMPAGainOptimizationNodeSimplexBiImpl0(*args):
    patternsList = [
        ["@NonNull String[] jpaAgents", "@NonNull String[] readoutAgents", "boolean pumpWithMixer", "float jpaOffLoPower", "int maxIteration", "@NonNull float[] biasAmplitudes", "@NonNull float[] pumpAmplitudeLBs", "@NonNull float[] pumpAmplitudeUBs", "@NonNull float[] pumpLoFrequencyLBs", "@NonNull float[] pumpLoFrequencyUBs", "@NonNull float[] pumpAmplitudeDeltas", "@NonNull float[] pumpLoFrequenciesDeltas", "float g0", "float g1", "float g2", "float loMinFrequency", "@Nonnegative float minGain", "@Nonnegative float maxGain", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runIMPAGainOptimizationNodeSimplexBiImpl0(*args)
            return
    raise TypeError('no input pattern match in runIMPAGainOptimizationNodeSimplexBiImpl0')
    
def runIMPAGainOptimizationNodeDETriImpl0(*args):
    patternsList = [
        ["@NonNull String[] jpaAgents", "@NonNull String[] readoutAgents", "boolean pumpWithMixer", "float jpaOffLoPower", "int maxIteration", "@NonNull float[] biasAmplitudeLBs", "@NonNull float[] biasAmplitudeUBs", "@NonNull float[] pumpAmplitudeLBs", "@NonNull float[] pumpAmplitudeUBs", "@NonNull float[] pumpLoFrequencyLBs", "@NonNull float[] pumpLoFrequencyUBs", "int populationSize", "boolean adaptivePopulationSize", "float populationShrinkRatio", "int initialIterations", "int minimumPopulationSize", "float g0", "float g1", "float g2", "float loMinFrequency", "@Nonnegative float minGain", "@Nonnegative float maxGain", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runIMPAGainOptimizationNodeDETriImpl0(*args)
            return
    raise TypeError('no input pattern match in runIMPAGainOptimizationNodeDETriImpl0')
    
def runIMPAGainOptimizationNodeDEBiImpl0(*args):
    patternsList = [
        ["@NonNull String[] jpaAgents", "@NonNull String[] readoutAgents", "boolean pumpWithMixer", "float jpaOffLoPower", "int maxIteration", "@NonNull float[] biasAmplitudes", "@NonNull float[] pumpAmplitudeLBs", "@NonNull float[] pumpAmplitudeUBs", "@NonNull float[] pumpLoFrequencyLBs", "@NonNull float[] pumpLoFrequencyUBs", "int populationSize", "boolean adaptivePopulationSize", "float populationShrinkRatio", "int initialIterations", "int minimumPopulationSize", "float g0", "float g1", "float g2", "float loMinFrequency", "@Nonnegative float minGain", "@Nonnegative float maxGain", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runIMPAGainOptimizationNodeDEBiImpl0(*args)
            return
    raise TypeError('no input pattern match in runIMPAGainOptimizationNodeDEBiImpl0')
    
def runOptimalReadoutFrequencyCalNode(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] biasAwayQubits", "@NonNull float[] biasAmplitudes", "@NonNull float[] frequencyRanges", "int numSamples", "float minSNR", "float minDataSNR", "float frequencyChangeUB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"],

        ["@NonNull String[] qubits", "@NonNull String[] biasAwayQubits", "@NonNull float[] biasAmplitudes", "boolean measureState2", "boolean forParamSet012", "@NonNull float[] frequencyRanges", "int numSamples", "float minSNR", "float minDataSNR", "float frequencyChangeUB", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runOptimalReadoutFrequencyCalNode(*args)
            return
    raise TypeError('no input pattern match in runOptimalReadoutFrequencyCalNode')
    
def runReadoutFrequencyNAmplitudeOptimizerNodeImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] biasAwayQubits", "@NonNull float[] biasAmplitudes", "@NonNull float[] dipWidths", "float snrLB", "float outlierRatioUB", "float frequencyChangeUB", "float amplitudeChangeRatioUB", "boolean measureState2", "int maxIteration", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runReadoutFrequencyNAmplitudeOptimizerNodeImpl0(*args)
            return
    raise TypeError('no input pattern match in runReadoutFrequencyNAmplitudeOptimizerNodeImpl0')
    
def runXYGateAmplitudeRabiCalNodeImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] workBiasQubits", "@NonNull float[] workBiasAmplitudes", "int numDataPoints", "@NonNull int[] numPis", "@NonNull String gate", "float fitErrorRatioUB", "float minVisibility", "float maxDrift", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runXYGateAmplitudeRabiCalNodeImpl0(*args)
            return
    raise TypeError('no input pattern match in runXYGateAmplitudeRabiCalNodeImpl0')
    
def runXYGateAmplitudeRabiCalNodeWithBackupImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "@NonNull String[] workBiasQubits", "@NonNull float[] workBiasAmplitudes", "int numDataPoints", "@NonNull int[] numPisFine", "@NonNull int[] numPisCoarse", "@NonNull String gate", "float fitErrorRatioUB", "float minVisibility", "float maxDrift", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runXYGateAmplitudeRabiCalNodeWithBackupImpl0(*args)
            return
    raise TypeError('no input pattern match in runXYGateAmplitudeRabiCalNodeWithBackupImpl0')
    
def runZDistortionCalNodeExpDecayImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "int zBiasLength", "@NonNull float[] zBiasAmplitudes", "int delay0", "int delay1", "int numDataPoints", "@NonNull float[] alphaLowerBound", "@NonNull float[] alphaUpperBound", "@NonNull int[] decayTimeUpperBound", "float lowpassFilterBandWidth", "@NonNull String phaseMode", "int slidingWindowWidth", "float maxResidualRatio", "float snrLB", "float fitErrorUB", "float phaseAmplitudeLB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runZDistortionCalNodeExpDecayImpl0(*args)
            return
    raise TypeError('no input pattern match in runZDistortionCalNodeExpDecayImpl0')
    
def runF01FinderNodeImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "int driveLength", "@NonNull float[] driveAmplitudes", "float maxSBFrequency", "float minSBFrequency", "@NonNull float[] backgroundBiasAmplitudes", "float frequencyRange", "float frequencyStep", "@NonNull String[] detuneAgents", "@NonNull float[] detuneAmplitudes", "int smoothSpan", "float f01LB", "float f01UB", "float snrLB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runF01FinderNodeImpl0(*args)
            return
    raise TypeError('no input pattern match in runF01FinderNodeImpl0')
    
def runF01BiasDependencyNodeImpl0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "boolean isDCBias", "int driveLength", "@NonNull float[] driveAmplitudes", "float peakAmplitudeLB", "float loFrequency", "float frequencyRange", "float frequencyStep", "@NonNull String[] detuneAgents", "@NonNull float[] detuneAmplitudes", "boolean fixedFahFit", "float fah", "float fitErrorUB", "float frequencyLB", "float minTuneRange", "float kfEstimation", "int smoothSpan", "@NonNull float[] biasLBs", "@NonNull float[] biasUBs", "@NonNull float[] biasSteps", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots", "boolean verbose"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runF01BiasDependencyNodeImpl0(*args)
            return
    raise TypeError('no input pattern match in runF01BiasDependencyNodeImpl0')
    
def runT1VsF01CalNodeLatestValueImpl(*args):
    patternsList = [
        ["@NonNull String[] qubits", "boolean measureReference", "@NonNull float[] f0s", "@NonNull float[] f1s", "float f01Step", "@NonNull int[] maxDelays", "int numSamples", "int defaultF01WindowWidth", "@NonNull float defaultExpireTime", "@NonNull float[] defaultErrorValues", "@NonNull float[] defaultErrorWeights", "float fitErrorUB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runT1VsF01CalNodeLatestValueImpl(*args)
            return
    raise TypeError('no input pattern match in runT1VsF01CalNodeLatestValueImpl')
    
def runT1VsF01CalNodeMeanValueImpl(*args):
    patternsList = [
        ["@NonNull String[] qubits", "boolean measureReference", "@NonNull float[] f0s", "@NonNull float[] f1s", "float f01Step", "@NonNull int[] maxDelays", "int numSamples", "int defaultF01WindowWidth", "@NonNull float defaultExpireTime", "@NonNull float[] defaultErrorValues", "@NonNull float[] defaultErrorWeights", "float fitErrorUB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runT1VsF01CalNodeMeanValueImpl(*args)
            return
    raise TypeError('no input pattern match in runT1VsF01CalNodeMeanValueImpl')
    
def runT1VsF01CalNodeTimeExpDecayWeightImpl(*args):
    patternsList = [
        ["@NonNull String[] qubits", "boolean measureReference", "@NonNull float[] f0s", "@NonNull float[] f1s", "float f01Step", "@NonNull int[] maxDelays", "int numSamples", "int defaultF01WindowWidth", "@NonNull float defaultExpireTime", "@NonNull float[] defaultErrorValues", "@NonNull float[] defaultErrorWeights", "float decayTimeConstant", "float fitErrorUB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runT1VsF01CalNodeTimeExpDecayWeightImpl(*args)
            return
    raise TypeError('no input pattern match in runT1VsF01CalNodeTimeExpDecayWeightImpl')
    
def runZXTalkCalNodeImpl0(*args):
    patternsList = [
        ["@NonNull String sourceQubit", "@NonNull String targetQubit", "int pulseLength", "int numPulses", "int numDataPoints", "float maxReferenceBiasAmplitude", "float maxXtalkBiasAmplitude", "float correctionTol", "float xTalkFactorUB", "float fitErrorUB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runZXTalkCalNodeImpl0(*args)
            return
    raise TypeError('no input pattern match in runZXTalkCalNodeImpl0')
    
def runDriveBiasTimingCalBaseNodeImpl0(*args):
    patternsList = [
        ["@NonNull String[] driveQubits", "@NonNull String[] biasAgents", "@NonNull String[] biasAgentTypes", "@NonNull int[] zBiasLengths", "@NonNull float[] zBiasAmplitudes", "boolean netZeroBias", "int startDelay", "int stopDelay", "float delayUB", "float snrLB", "float dipAmplitudeLB", "float backgroundDifferenceUB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runDriveBiasTimingCalBaseNodeImpl0(*args)
            return
    raise TypeError('no input pattern match in runDriveBiasTimingCalBaseNodeImpl0')
    
def runFSimThetaVsGCalNodeImpl0(*args):
    patternsList = [
        ["@NonNull String[] couplers", "@NonNull int[] fSimIndexes", "int numGates", "boolean isFineCal", "int numDataPoints", "float maxGChange", "float minSwapAmplitude", "float minSNR", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runFSimThetaVsGCalNodeImpl0(*args)
            return
    raise TypeError('no input pattern match in runFSimThetaVsGCalNodeImpl0')
    
def runFSimThetaVsDetuneCalNodeImpl0(*args):
    patternsList = [
        ["@NonNull String[] couplers", "@NonNull int[] fSimIndexes", "int numGates", "@NonNull boolean[] isTune1stQubit", "@NonNull float[] detuneRanges", "int numDataPoints", "float minSwapAmplitude", "float checkRange", "float maxDetune", "float minSNR", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runFSimThetaVsDetuneCalNodeImpl0(*args)
            return
    raise TypeError('no input pattern match in runFSimThetaVsDetuneCalNodeImpl0')
    
def runIQVsXTGBiasCalNodeImpl0(*args):
    patternsList = [
        ["@NonNull String[] couplers", "@NonNull boolean[] measureQ0s", "@NonNull String[] detuneQubits", "@NonNull float[] detuneAmplitudes", "boolean isDCDetune", "@NonNull float[] bias0s", "@NonNull float[] bias1s", "int numBiases", "float snrLB", "float minPeakSeparation", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runIQVsXTGBiasCalNodeImpl0(*args)
            return
    raise TypeError('no input pattern match in runIQVsXTGBiasCalNodeImpl0')
    
def runXTGZeroPointCoarseCalNodePhaseImpl0(*args):
    patternsList = [
        ["@NonNull String[] couplers", "@NonNull boolean[] measureQ0s", "int numDataPoints", "@NonNull int[] interactionDurations", "boolean detuneQubits", "float changeUB", "float minPhaseUB", "float snrLB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runXTGZeroPointCoarseCalNodePhaseImpl0(*args)
            return
    raise TypeError('no input pattern match in runXTGZeroPointCoarseCalNodePhaseImpl0')
    
def runXTGZeroPointCalNodeSwapImpl0(*args):
    patternsList = [
        ["@NonNull String[] couplers", "int numDataPoints", "@NonNull float[] detuneAmplitude0s", "@NonNull float[] detuneAmplitude1s", "@NonNull float[] biasAmplitude0s", "@NonNull float[] biasAmplitude1s", "@NonNull int[] interactionDurations", "boolean fineTune", "float changeUB", "float minPhaseUB", "float snrLB", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runXTGZeroPointCalNodeSwapImpl0(*args)
            return
    raise TypeError('no input pattern match in runXTGZeroPointCalNodeSwapImpl0')
    
def runF01XTGBiasDependencyCalNodeImpl0(*args):
    patternsList = [
        ["@NonNull String[] couplers", "@NonNull boolean[] isQubit0s", "int driveLength", "@NonNull float[] driveAmplitudes", "float peakAmplitudeLB", "float maxSBFrequency", "float frequencyRange", "float frequencyStep", "float frequencyLB", "int smoothSpan", "@NonNull float[] biasLBs", "@NonNull float[] biasUBs", "@NonNull float[] biasSteps", "float f01ShiftPositiveMin", "float f01ShiftNegativeMin", "boolean continuousExecution", "boolean enableParallelMode", "boolean saveRawData", "int numShots", "boolean verbose"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runF01XTGBiasDependencyCalNodeImpl0(*args)
            return
    raise TypeError('no input pattern match in runF01XTGBiasDependencyCalNodeImpl0')
    
def createControlGraph(*args):
    patternsList = [
        ["@NonNull String controlGraphName", "boolean deleteIfAlreadyCreate"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.createControlGraph(*args)
            return
    raise TypeError('no input pattern match in createControlGraph')
    
def deleteControlGraph(*args):
    patternsList = [
        ["@NonNull String controlGraphName"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.deleteControlGraph(*args)
            return
    raise TypeError('no input pattern match in deleteControlGraph')
    
def reloadControlNode(*args):
    patternsList = [
        ["@NonNull String controlGraphName", "@NonNull String nodeName"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.reloadControlNode(*args)
            return
    raise TypeError('no input pattern match in reloadControlNode')
    
def setControlNodeOutOfSpec(*args):
    patternsList = [
        ["@NonNull String controlGraphName", "@NonNull String[] nodesToSet"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.setControlNodeOutOfSpec(*args)
            return
    raise TypeError('no input pattern match in setControlNodeOutOfSpec')
    
def maintainControlGraph(*args):
    patternsList = [
        ["@NonNull String controlGraphName", "@NonNull String nodeName", "@NonNull String[][] calAgentGroups", "boolean ignoreFailure"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.maintainControlGraph(*args)
            return
    raise TypeError('no input pattern match in maintainControlGraph')
    
def controlNodeRunCal(*args):
    patternsList = [
        ["@NonNull String controlGraphName", "@NonNull String nodeName", "boolean update"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.controlNodeRunCal(*args)
            return
    raise TypeError('no input pattern match in controlNodeRunCal')
    
def controlNodeTestOp(*args):
    patternsList = [
        ["@NonNull String controlGraphName", "@NonNull String[] nodeNames", "int op"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.controlNodeTestOp(*args)
            return
    raise TypeError('no input pattern match in controlNodeTestOp')
    
def runSetQubitWorkingPointTest0(*args):
    patternsList = [
        ["@NonNull String[] qubits", "float reservedDynamicRangeP", "float reservedDynamicRangeN", "float f01FinderFrequencyRange", "@NonNull float[] targetF01s", "@NonNull float[] loFrequencies"]]
    for patterns in patternsList:
        if matchArgument(patterns, args):
            args = convertArgument(patterns, args)
            g.Instance.runSetQubitWorkingPointTest0(*args)
            return
    raise TypeError('no input pattern match in runSetQubitWorkingPointTest0')
    
